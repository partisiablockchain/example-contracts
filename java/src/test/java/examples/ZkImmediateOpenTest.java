package examples;

import com.partisiablockchain.BlockchainAddress;
import com.partisiablockchain.language.abicodegen.ZkImmediateOpen;
import com.partisiablockchain.language.junit.ContractBytes;
import com.partisiablockchain.language.junit.ContractTest;
import com.partisiablockchain.language.junit.JunitContractTest;
import com.secata.stream.BitOutput;
import com.secata.stream.CompactBitArray;
import java.nio.file.Path;
import org.assertj.core.api.Assertions;

/** Test suite for the ZkImmediateOpen contract. */
public final class ZkImmediateOpenTest extends JunitContractTest {

  private static final ContractBytes IMMEDIATE_OPEN_BYTES =
      ContractBytes.fromPaths(
          Path.of("../rust/target/wasm32-unknown-unknown/release/zk_immediate_open.zkwa"),
          Path.of("../rust/target/wasm32-unknown-unknown/release/zk_immediate_open.abi"),
          Path.of(
              "../rust/target/wasm32-unknown-unknown/release/zk_immediate_open_contract_runner"));

  private BlockchainAddress account1;
  private BlockchainAddress account2;

  private BlockchainAddress immediateOpen;

  /** Deploys the contract. */
  @ContractTest
  void deploy() {
    account1 = blockchain.newAccount(2);
    account2 = blockchain.newAccount(3);

    byte[] initRpc = ZkImmediateOpen.initialize();

    immediateOpen = blockchain.deployZkContract(account1, IMMEDIATE_OPEN_BYTES, initRpc);

    final var contractByteState = blockchain.getContractState(immediateOpen);

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(contractByteState);

    Assertions.assertThat(state).isNotNull();
  }

  /** Sends secret input to the contract and asserts that it is opened immediately. */
  @ContractTest(previous = "deploy")
  void sendSecretInput() {
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(10), new byte[] {0x40});

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().get(0)).isEqualTo(10);

    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(11), new byte[] {0x40});
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(12), new byte[] {0x40});
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(13), new byte[] {0x40});
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(14), new byte[] {0x40});
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(15), new byte[] {0x40});

    state = ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().get(1)).isEqualTo(11);
    Assertions.assertThat(state.openedInputs().get(2)).isEqualTo(12);
    Assertions.assertThat(state.openedInputs().get(3)).isEqualTo(13);
    Assertions.assertThat(state.openedInputs().get(4)).isEqualTo(14);
    Assertions.assertThat(state.openedInputs().get(5)).isEqualTo(15);
  }

  private CompactBitArray createSecretInput(Integer secret) {
    return BitOutput.serializeBits(output -> output.writeSignedInt(secret, 32));
  }
}
