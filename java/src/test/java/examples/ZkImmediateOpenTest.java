package examples;

import com.partisiablockchain.BlockchainAddress;
import com.partisiablockchain.language.abicodegen.ZkImmediateOpen;
import com.partisiablockchain.language.junit.ContractBytes;
import com.partisiablockchain.language.junit.ContractTest;
import com.partisiablockchain.language.junit.JunitContractTest;
import com.partisiablockchain.language.testenvironment.zk.node.task.PendingInputId;
import com.partisiablockchain.language.testenvironment.zk.node.task.PendingOpenId;
import com.secata.stream.BitOutput;
import com.secata.stream.CompactBitArray;
import java.nio.file.Path;
import java.util.List;
import org.assertj.core.api.Assertions;

/** Test suite for the ZkImmediateOpen contract. */
public final class ZkImmediateOpenTest extends JunitContractTest {

  private static final ContractBytes IMMEDIATE_OPEN_BYTES =
      ContractBytes.fromPaths(
          Path.of("../rust/target/wasm32-unknown-unknown/release/zk_immediate_open.zkwa"),
          Path.of("../rust/target/wasm32-unknown-unknown/release/zk_immediate_open.abi"),
          Path.of(
              "../rust/target/wasm32-unknown-unknown/release/zk_immediate_open_contract_runner"));

  private BlockchainAddress account1;
  private BlockchainAddress account2;
  private BlockchainAddress immediateOpen;

  /** Deploys the contract. */
  @ContractTest
  void deploy() {
    account1 = blockchain.newAccount(2);
    account2 = blockchain.newAccount(3);

    byte[] initRpc = ZkImmediateOpen.initialize();

    immediateOpen = blockchain.deployZkContract(account1, IMMEDIATE_OPEN_BYTES, initRpc);

    final var contractByteState = blockchain.getContractState(immediateOpen);

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(contractByteState);

    Assertions.assertThat(state).isNotNull();
    Assertions.assertThat(state.openedInputs()).isEmpty();
  }

  /** An input from a user is immediately opened and made public. */
  @ContractTest(previous = "deploy")
  void sendSecretInput() {
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(10), new byte[] {0x40});

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().get(0)).isEqualTo(10);

    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(11), secretInputRpc());
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(12), secretInputRpc());
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(13), secretInputRpc());
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(14), secretInputRpc());
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(15), secretInputRpc());

    state = ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().get(1)).isEqualTo(11);
    Assertions.assertThat(state.openedInputs().get(2)).isEqualTo(12);
    Assertions.assertThat(state.openedInputs().get(3)).isEqualTo(13);
    Assertions.assertThat(state.openedInputs().get(4)).isEqualTo(14);
    Assertions.assertThat(state.openedInputs().get(5)).isEqualTo(15);
  }

  /** A user can remove all publicized user inputs. */
  @ContractTest(previous = "deploy")
  void resetState() {
    // Send secret input
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(10), secretInputRpc());

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().size()).isEqualTo(1);
    Assertions.assertThat(state.openedInputs().get(0)).isEqualTo(10);

    // Reset state
    byte[] resetState = ZkImmediateOpen.resetContract();
    blockchain.sendAction(account1, immediateOpen, resetState);

    state = ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));
    Assertions.assertThat(state.openedInputs().size()).isEqualTo(0);
  }

  /** User inputs cannot be sent, while making another input public. */
  @ContractTest(previous = "deploy")
  void sendSecondSecretInputBeforeComputing() {
    zkNodes.stop();

    blockchain.sendSecretInput(immediateOpen, account1, createSecretInput(1), secretInputRpc());
    blockchain.sendSecretInput(immediateOpen, account2, createSecretInput(2), secretInputRpc());

    List<PendingInputId> pendingInputs = zkNodes.getPendingInputs(immediateOpen);

    zkNodes.confirmInput(pendingInputs.get(0));

    Assertions.assertThatThrownBy(() -> zkNodes.confirmInput(pendingInputs.get(1)))
        .isInstanceOf(RuntimeException.class)
        .hasMessageContaining(
            "Unable to start computation or move to done when not in state WAITING.");

    zkNodes.zkCompute(immediateOpen);

    for (PendingOpenId pendingOpen : zkNodes.getPendingOpens(immediateOpen)) {
      zkNodes.openVariable(pendingOpen);
    }

    ZkImmediateOpen.ContractState state =
        ZkImmediateOpen.ContractState.deserialize(blockchain.getContractState(immediateOpen));

    Assertions.assertThat(state.openedInputs().size()).isEqualTo(1);
    Assertions.assertThat(state.openedInputs().get(0)).isEqualTo(1);
  }

  private CompactBitArray createSecretInput(Integer secret) {
    return BitOutput.serializeBits(output -> output.writeSignedInt(secret, 32));
  }

  byte[] secretInputRpc() {
    return new byte[] {0x40};
  }
}
